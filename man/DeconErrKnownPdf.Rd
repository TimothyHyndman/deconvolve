% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DeconErrKnownPdf.R
\name{DeconErrKnownPdf}
\alias{DeconErrKnownPdf}
\title{Deconvolution when the error distribution is known}
\usage{
DeconErrKnownPdf(xx, W, h, errortype, sigU, phiU, rescale = FALSE,
  phiK = NULL, muK2 = 6, RK = 1024/3003/pi, tt = seq(-1, 1, 2e-04))
}
\arguments{
\item{xx}{A vector of x values on which to compute the density.}

\item{W}{A vector of the univariate contaminated data.}

\item{h}{The bandwidth to use.}

\item{errortype}{The distribution type of \eqn{U}. Either "Lap" for Laplace 
errors or "norm" for normal errors. If you define the errors this way then 
you must also provide \code{sigU} but should not provide \code{phiU}.}

\item{sigU}{The standard deviation of \eqn{U}.}

\item{phiU}{A function giving the characteristic function of \eqn{U}. If you 
define the errors this way then you should not provide \code{errortype} or 
\code{sigU}.}

\item{rescale}{If \code{TRUE}, estimator is rescaled so that it 
integrates to 1. Rescaling requires \code{xx} to be a fine grid of equispaced 
\eqn{x} values that covers the whole range of \eqn{x}-values where the 
estimated density is significantly non zero.}

\item{phiK}{A function giving the fourier transform of the kernel. 
If supplied, \code{muK2}, \code{RK}, and \code{tt} must also be supplied. If 
not supplied it defaults to \eqn{(1 - t^2)^3} on the interval \eqn{[-1,1]}.}

\item{muK2}{The second moment of the kernel, i.e. \eqn{\int x^2 K(x) dx}.}

\item{RK}{The integral of the square of the kernel, i.e. \eqn{\int K^2(x) dx}.}

\item{tt}{A vector of evenly spaced t values on which to approximate the 
integrals in the Fourier domain. If phiK is compactly supported, the first 
and last elements of \code{tt} must be the lower and upper bound of the 
support of phiK. If phiK is not compactly supported, the first and last 
elements of \code{tt} must be large enough for your discretisation of the 
integrals to be accurate.}
}
\value{
A vector containing the deconvolution KDE evaluated at each point in 
\code{xx}.
}
\description{
Computes the deconvolution kernel density estimator (KDE) of \eqn{X} from 
data \eqn{W = X + U} when the distribution of \eqn{U} is known.
}
\details{
PUT DETAILS HERE
}
\section{Author}{

Aurore Delaigle
}

\section{References}{

}

\section{Warnings}{

\itemize{
\item The arguments \code{phiK}, \code{muK2}, \code{RK}, and \code{tt} must
	all be calculated from the same kernel. If you change one of these, you must
	also change the rest to match.
\item The kernel used here must match the kernel used to compute the 
	bandwidth.
\item The DKDE can also be computed using the Fast Fourier Transform, which 
	is a bit more complex. See Delaigle, A. and Gijbels, I. (2007). Frequent 
	problems in calculating integrals and optimizing objective functions: a case 
	study in density deconvolution. \emph{Statistics and Computing}, 17, 
	349-355. However if the grid of t-values is fine enough, the estimator can 
	simply be computed like here without having problems with oscillations.
}
}

\examples{
#-----------------------------------------------------
#Start by generating some data contaminated by noise:
#-----------------------------------------------------

#Noise to signal ratio=varU/varX
NSR=0.2

#Sample size
n=200

#Generate data from a normal mixture
mu1=-3;
mu2=2;
sig1=1;
sig2=1;

X=rnorm(n,mu1,sig1);
X2=rnorm(n,mu2,sig2);

pmix=0.75;
tmp=matrix(runif(n,0,1),nrow=1,ncol=n,byrow=TRUE);
X[which(tmp<pmix)]=X2[which(tmp<pmix)];

#Grid where to estimate the true mixture density, and calculation of true 
#density
xx=seq(-5,5,0.1);
dx=xx[2]-xx[1];
truedens=(1-pmix)*dnorm(xx,mu1,sig1)+pmix*dnorm(xx,mu2,sig2);


#-------------------------------------
#Example when the error is normal
#-------------------------------------

errortype="norm";
sigU=sqrt(NSR*var(X));
U=rnorm(n,0,sigU);
W=as.vector(X+U);

#Plot the true density
plot(xx,truedens,'l',col='red',xlab="",ylab="")

#PI bandwidth of Delaigle and Gijbels
hPI=PI_deconvUknownth4(n,W,errortype,sigU);

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y=DeconErrKnownPdf(xx,W,hPI,errortype,sigU);

#DKDE estimator with rescaling: here xx must be equispaced and must cover the 
#range where the estimated density is significantly non zero
y2=DeconErrKnownPdf(xx,W,hPI,errortype,sigU,rescale=1);

lines(xx,y2,col="green",xlab="",ylab="")
lines(xx,y,col='black')



#CV bandwidth of Stefanski and Carroll
hCV=CVdeconv(n,W,errortype,sigU)

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y3=DeconErrKnownPdf(xx,W,hCV,errortype,sigU);

lines(xx,y3,col='magenta')



#Compare with the naive KDE estimator that ignores the error (using normal 
#reference bandwidth and standard normal kernel)
h=1.06*sqrt(var(W))*n^(-1/5);
xout=outerop(xx,t(W),"-");

fnaive=apply(dnorm(xout,0,h),1,sum)/n;

lines(xx,fnaive,col='cyan')


legend(x="topright",legend=c( "true f","fdec, hPI", "fdec rescaled, hPI", 
	   "fdec rescaled, hCV", "naive estimator, hNR"),
	   col=c("red","black","green","magenta","cyan"),lty=c(1,1,1,1),cex=0.73)



#-------------------------------------
#Example when the error is Laplace
#-------------------------------------
#windows()
errortype="Lap"
sigLap=sqrt(NSR*var(X)/2)
sigU=sqrt(2)*sigLap;
U=rlap(sigLap,1,n);

#Contaminated data
W=as.vector(X+U);


#Plot the true density
plot(xx,truedens,'l',col='red',xlab="",ylab="")

#PI bandwidth of Delaigle and Gijbels
hPI=PI_deconvUknownth4(n,W,errortype,sigU);


#DKDE estimator without rescaling (density does not integrate exactly to 1)
y=DeconErrKnownPdf(xx,W,hPI,errortype,sigU);

#DKDE estimator with rescaling: here xx must be equispaced and must cover the 
#range where the estimated density is significantly non zero
y2=DeconErrKnownPdf(xx,W,hPI,errortype,sigU,rescale=1);

lines(xx,y2,col="green",xlab="",ylab="")
lines(xx,y,col='black')



#CV bandwidth of Stefanski and Carroll
hCV=CVdeconv(n,W,errortype,sigU)

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y3=DeconErrKnownPdf(xx,W,hCV,errortype,sigU);

lines(xx,y3,col='magenta')



#Compare with the naive KDE estimator that ignores the error (using normal 
#reference bandwidth and standard normal kernel)
h=1.06*sqrt(var(W))*n^(-1/5);
xout=outerop(xx,t(W),"-");

fnaive=apply(dnorm(xout,0,h),1,sum)/n;

lines(xx,fnaive,col='cyan')


legend(x="topright",legend=c( "true f","fdec, hPI", "fdec rescaled, hPI", 
	   "fdec rescaled, hCV", "naive estimator, hNR"),
	   col=c("red","black","green","magenta","cyan"),lty=c(1,1,1,1),cex=0.73)
}

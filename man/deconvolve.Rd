% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deconvolve.R
\name{deconvolve}
\alias{deconvolve}
\title{Deconvolution Kernel Density Estimator}
\usage{
deconvolve(W, W2 = NULL, xx = seq(min(W), max(W), length.out = 100),
  errortype = NULL, sd_U = NULL, phiU = NULL, bw = NULL,
  rescale = FALSE, pmf = FALSE, kernel_type = c("default", "normal",
  "sinc"), m = 20, show_diagnostics = FALSE, het_replicates = FALSE)
}
\arguments{
\item{W}{A vector of the univariate contaminated data.}

\item{W2}{A vector of replicate measurements. If supplied, then the error 
will be estimated using replicates.}

\item{xx}{A vector of x values on which to compute the density. This can be
missing if \code{pmf = TRUE}.}

\item{errortype}{The distribution type of \eqn{U}. Either "laplace" or 
"normal". If you define the errors this way then you must also provide 
\code{sd_U} but should not provide \code{phiU}. Argument is case-insensitive
and partially matched.}

\item{sd_U}{The standard deviations of \eqn{U}. A single value for
homoscedastic errors and a vector having the same length as \code{W} for 
heteroscedastic errors. This does not need to be provided if you define your
error using phiU and provide \code{bw}.}

\item{phiU}{A function giving the characteristic function of \eqn{U}. A 
single value for homoscedastic errors and a vector having the same length as 
\code{W} for heteroscedastic errors. If you define the errors this way then 
you should not provide \code{errortype}.}

\item{bw}{The bandwidth to use. If \code{NULL}, a bandwidth will be
calculated using an appropriate plug-in estimator.}

\item{rescale}{If \code{TRUE}, estimator is rescaled so that it 
integrates to 1. Rescaling requires \code{xx} to be a fine grid of equispaced 
\eqn{x} values that covers the whole range of \eqn{x}-values where the 
estimated density is significantly non zero.}

\item{pmf}{If \code{TRUE}, returns a probability mass function instead of a 
density as the estimator. This is quicker than estimating a density. To use
this option, the errors must not be provided.}

\item{kernel_type}{The deconvolution kernel to use. The default kernel has
characteristic function \eqn{(1-t^2)^3}.}

\item{m}{The number of point masses to use to estimate the distribution of 
\eqn{X} when the error is not supplied.}

\item{show_diagnostics}{For testing only, REMOVE IN FINAL PACKAGE}

\item{het_replicates}{If \code{TRUE}, then a method more appropriate for 
heteroscedastic errors is used. Only applicable if \code{W2} is supplied.}
}
\value{
An object of class "\code{deconvolve}".

The function \code{plot} produces a plot of the deconvolution KDE.

An object of class "\code{deconvolve}" is a list containing at least some of
the elements:
\item{W}{The original contaminated data}
\item{x}{The values on which the deconvolution KDE is evaluated.}
\item{pdf}{A vector containing the deconvolution KDE evaluated at each point 
in \code{x}}
\item{support}{The support of the pmf found when the errors are assumed
symmetric}
\item{probweights}{The probability masses of the pmf found when the errors
are assumed symmetric}
}
\description{
Computes the deconvolution kernel density estimator (KDE) of \eqn{X} from 
data \eqn{W = X + U} when the distribution of \eqn{U} is known, unknown, or
estimated from replicates, \eqn{W_2 = X + U_2}.
}
\details{
The function \code{deconvolve} chooses from one of four different methods 
depending on how the error distribution is defined.

\strong{Error from Replicates:} If both \code{W} and \code{W2} are supplied 
then the error is calculated using replicates. This method was prototyped in  
Delaigle, Hall, and Meister 2008 and then further refined in Delaigle and  
Hall 2016, and Camirand, Carroll, and Delaigle 2018.

\strong{Heteroscedastic Error from Replicates}: If both \code{W} and 
\code{W2} are supplied then the error is caculated as described in Delaigle
and Meister 2008, using the alternative estimator for when the errors are 
heteroscedastic. Refinements have been made based on Delaigle and Hall 2016, 
and Camirand, Carroll, and Delaigle 2018.

\strong{Symmetric Error:} If none of \code{errortype}, \code{phiU}, or 
\code{W2} are supplied then the error is assumed symmetric and the 
deconvolution method is based on the method described in Delaigle and Hall 
2016.

\strong{Homoscedastic Error:} If the errors are defined by either a single 
function \code{phiU}, or a single value \code{sd_U} along with its 
\code{errortype} then the method used is as described in Stefanski and
Carroll 1990.

\strong{Heteroscedastic Errors:} If the errors are defined by a either a 
vector of functions \code{phiU}, or a vector \code{sd_U} along with its 
\code{errortype} then the method used is as described in Delaigle and 
Meister 2008.

Errors can be defined by either a distribution type (\code{errortype}) along 
with the standard deviation(s) (\code{sd_U}), or by the characteristic 
function(s) of the errors (\code{phiU}).
}
\section{Warnings}{

\itemize{
\item The method for deconvolution when the error is unknown and assumed
  symmetric (as described in Delaigle and Hall (2016)) requires solving a 
  non-linear objective function with both linear and non-linear constraints. 
  We are yet to find a package in R that can perform this reliably. We instead
  recommend using the MATLAB code found at <URL> as it is both faster, and 
  more reliable.
\item If you supply your own bandwidth, then you should ensure that the
	kernel used here matches the one you used to calculate your bandwidth.
\item The DKDE can also be computed using the Fast Fourier Transform, which 
	is a bit more complex. See Delaigle and Gijbels 2007. However if the grid of 
	t-values is fine enough, the estimator can simply be computed like here 
	without having problems with oscillations.
}
}

\section{References}{

Stefanski, L.A. and Carroll, R.J. (1990). Deconvolving kernel density
estimators. \emph{Statistics}, 21, 2, 169-184.

Delaigle, A. and Gijbels, I. (2007). Frequent problems in calculating 
integrals and optimizing objective functions: a case study in density 
deconvolution. \emph{Statistics and Computing}, 17, 349-355.

Delaigle, A. and Meister, A. (2008). Density estimation with heteroscedastic 
error. \emph{Bernoulli}, 14, 2, 562-579.

Delaigle, A., Hall, P., and Meister, A. (2008). On Deconvolution with  
repeated measurements. \emph{Annals of Statistics}, 36, 665-685 

Delaigle, A. and Hall, P. (2016). Methodology for non-parametric 
deconvolution when the error distribution is unknown. \emph{Journal of the 
Royal Statistical Society: Series B (Statistical Methodology)}, 78, 1, 
231-252.

Camirand, F., Carroll, R.J., and Delaigle, A. (2018). Estimating the  
distribution of episodically consumed food measured with errors.  
\emph{Manuscript.}
}

\examples{
\dontrun{
# Error estimated from replicates ----------------------------------------------
W1 <- (framingham$SBP21 + framingham$SBP22)/2
W2 <- (framingham$SBP31 + framingham$SBP32)/2

yy <- deconvolve(W1, W2)

# Symmetric Errors -------------------------------------------------------------
output <- deconvolve((framingham$SBP21 + framingham$SBP22)/2)

# Homoscedastic Errors ---------------------------------------------------------
n <- 50
sd_X <- 1
sd_U <- 0.2
W <- GenerateTestData(n, sd_X, sd_U, dist_type = "mix", error_type = "norm")
yy <- deconvolve(W, errortype = "norm", sd_U = sd_U)


# Heteroscedastic Errors -------------------------------------------------------
sd_U_vec <- 0.6 * sqrt(1 + (1:n) / n) * sqrt(0.5)
W <- GenerateTestData(n, sd_X, sd_U_vec, dist_type = "mix", error_type = "norm")

yy <- deconvolve(W, errortype = "norm", sd_U = sd_U_vec)

# Heteroscedastic Errors provided using a vector of phiUs ----------------------
W <- GenerateTestData(n, sd_X, sd_U_vec, dist_type = "mix", error_type = "norm")

phiU_vec=c()
phiU <- function(k) {
	function(tt){
		exp(-sd_U_vec[k]^2 * tt^2 / 2)
	}
}
for(k in 1:n) {	
	phiU_vec <- c(phiU_vec, phiU(k))
}

yy <- deconvolve(W, sd_U = sd_U_vec, phiU = phiU_vec)
}
}
\author{
Aurore Delaigle, Timothy Hyndman, Tianying Wang
}

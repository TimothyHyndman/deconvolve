% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hom_deconvolve_U_known.r
\name{hom_deconvolve_U_known}
\alias{hom_deconvolve_U_known}
\title{Deconvolution KDE when the error is known}
\usage{
hom_deconvolve_U_known(W, phiU, h, x = seq(min(W), max(W), length.out = 100),
  kernel_type = c("default", "normal", "sinc"), rescale = FALSE)
}
\arguments{
\item{W}{A vector of the univariate contaminated data.}

\item{phiU}{A function giving the characteristic function of \eqn{U}.}

\item{h}{The bandwidth to use.}

\item{x}{A vector of x values on which to compute the density.}

\item{kernel_type}{The deconvolution kernel to use. The default kernel has
characteristic function \eqn{(1-t^2)^3}.}

\item{rescale}{If \code{TRUE}, estimator is rescaled so that it 
integrates to 1. Rescaling requires \code{x} to be a fine grid of equispaced 
\eqn{x} values that covers the whole range of \eqn{x}-values where the 
estimated density is significantly non zero.}
}
\value{
An object of class "\code{deconvolve}" containing the elements
\item{W}{The original contaminated data}
\item{x}{The values on which the deconvolution KDE is evaluated.}
\item{pdf}{A vector containing the deconvolution KDE evaluated at each point 
in \code{x}}

The function \code{plot} produces a plot of the deconvolution KDE.
}
\description{
Computes the deconvolution kernel density estimator (KDE) of \eqn{X} from 
data \eqn{W = X + U} when the distribution of \eqn{U} is known and 
homoscedastic.
}
\details{
The method used is as described in Stefanski and Carroll 1990.
}
\section{Warnings}{

\itemize{
\item You should ensure that the kernel used here matches the one you used 
	to calculate your bandwidth.
\item The DKDE can also be computed using the Fast Fourier Transform, which 
	is a bit more complex. See Delaigle and Gijbels 2007. However if the grid of 
	t-values is fine enough, the estimator can simply be computed like here 
	without having problems with oscillations.
}
}

\section{References}{

Stefanski, L.A. and Carroll, R.J. (1990). Deconvolving kernel density
estimators. \emph{Statistics}, 21, 2, 169-184.

Delaigle, A. and Gijbels, I. (2007). Frequent problems in calculating 
integrals and optimizing objective functions: a case study in density 
deconvolution. \emph{Statistics and Computing}, 17, 349-355.
}

\examples{
# Homoscedastic Errors ---------------------------------------------------------
n <- 50
sd_X <- 1
sd_U <- 0.2
W <- GenerateTestData(n, sd_X, sd_U, dist_type = "mix", error_type = "norm")
yy <- deconvolve(W, errortype = "norm", sd_U = sd_U)

# Heteroscedastic Errors -------------------------------------------------------
sd_U_vec <- 0.6 * sqrt(1 + (1:n) / n) * sqrt(0.5)
W <- GenerateTestData(n, sd_X, sd_U_vec, dist_type = "mix", error_type = "norm")

yy <- deconvolve(W, errortype = "norm", sd_U = sd_U_vec)

# Heteroscedastic Errors provided using a vector of phiUs ----------------------
W <- GenerateTestData(n, sd_X, sd_U_vec, dist_type = "mix", error_type = "norm")

phiU_vec=c()
phiU <- function(k) {
	function(tt){
		exp(-sd_U_vec[k]^2 * tt^2 / 2)
	}
}
for(k in 1:n) {	
	phiU_vec <- c(phiU_vec, phiU(k))
}

yy <- deconvolve(W, sd_U = sd_U_vec, phiU = phiU_vec)
}
\author{
Aurore Delaigle, Timothy Hyndman, Tianying Wang
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bandwidth.R
\name{bandwidth}
\alias{bandwidth}
\title{Bandwidth Selectors for Deconvolution Kernel Density Estimation}
\usage{
bandwidth(W, errortype, sigU, phiU, Y = NULL, varX = NULL,
  algorithm = "PI", n_cores = NULL, phiK = NULL, muK2 = 6,
  RK = 1024/3003/pi, tt = seq(-1, 1, 2e-04))
}
\arguments{
\item{W}{A vector of the univariate contaminated data.}

\item{errortype}{The distribution type of \eqn{U}. Either "Lap" for Laplace 
errors or "norm" for normal errors. If you define the errors this way then 
you must also provide \code{sigU} but should not provide \code{phiU}.}

\item{sigU}{The standard deviations of \eqn{U}. A single value for
homoscedastic errors and a vector having the same length as \code{W} for 
heteroscedastic errors.}

\item{phiU}{A function giving the characteristic function of \eqn{U}. A 
single value for homoscedastic errors and a vector having the same length as 
\code{W} for heteroscedastic errors. If you define the errors this way then 
you should not provide \code{errortype} or \code{sigU}.}

\item{Y}{A vector of the univariate dependant data. Only required for 'SIMEX'
algorithm.}

\item{varX}{An estimate of the variance of \eqn{X}. Only required for 
heteroscedastic errors.}

\item{algorithm}{Either \code{"PI"} for plug-in estimator or \code{"CV"} for 
cross-validation estimator. If \code{"CV"} then the errors must be 
homoscedastic.}

\item{n_cores}{Number of cores to use when using SIMEX algorithm. If 
\code{NULL}, the number of cores to use will be automatically detected.}

\item{phiK}{A function giving the fourier transform of the kernel. 
If supplied, \code{muK2}, \code{RK}, and \code{tt} must also be supplied. If 
not supplied it defaults to \eqn{(1 - t^2)^3} on the interval \eqn{[-1,1]}.}

\item{muK2}{The second moment of the kernel, i.e. \eqn{\int x^2 K(x) dx}.}

\item{RK}{The integral of the square of the kernel, i.e. \eqn{\int K^2(x) dx}.}

\item{tt}{A vector of evenly spaced t values on which to approximate the 
integrals in the Fourier domain. If phiK is compactly supported, the first 
and last elements of \code{tt} must be the lower and upper bound of the 
support of phiK. If phiK is not compactly supported, the first and last 
elements of \code{tt} must be large enough for your discretisation of the 
integrals to be accurate.}
}
\value{
The bandwidth estimator. If using 'SIMEX' algorithm then returns a
list containing the bandwidth 'h' and ridge parameter 'rho'.
}
\description{
Computes a bandwidth for use in deconvolution kernel density estimation of 
\eqn{X} from data \eqn{W = X + U}. If 'SIMEX' algorithm used, computes a 
bandwidth for use in deconvolution regression of data \eqn{(W, Y)}  where
\eqn{Y = g(X) + V} and \eqn{W = X + U}.
}
\details{
The function \code{bandwidth} chooses from one of four different methods 
depending on how the error distribution is defined and which algorithm is
selected.

\strong{PI for Homoscedastic Error:} If \code{algorithm = "PI"} and the errors 
are defined by either a single function \code{phiU}, or a single value 
\code{sigU} along with its \code{errortype}, then the method used is as
described in Delaigle and Gijbels 2002, and Delaigle and Gijbels 2004.

\strong{PI for Heteroscedastic Error:} If \code{algorithm = "PI"} and the
errors are defined by a either a vector of functions \code{phiU}, or a vector 
\code{sigU} along with its \code{errortype} then the method used is as 
described in Delaigle and Meister 2008.

\strong{CV:} If \code{algorithm = "CV"} then the method used is as described 
in Stefanski and Carroll 1990, and Delaigle and Gijbels 2004.

\strong{SIMEX:} If \code{algorithm = "SIMEX"} then the method used is as 
described in Delaigle and Hall 2008.
}
\section{Warnings}{

\itemize{
	\item The arguments \code{phiK}, \code{muK2}, \code{RK}, and \code{tt} must
	all be calculated from the same kernel. If you change one of these, you must
	also change the rest to match.
}
}

\section{References}{

Delaigle, A. and Meister, A. (2008). Density estimation with heteroscedastic 
error. \emph{Bernoulli}, 14, 2, 562-579.

Delaigle, A. and Gijbels, I. (2002). Estimation of integrated squared density 
derivatives from a contaminated sample. \emph{Journal of the Royal 
Statistical Society, B}, 64, 4, 869-886.

Delaigle, A. and Gijbels, I. (2004). Practical bandwidth selection in 
deconvolution kernel density estimation. \emph{Computational Statistics and 
Data Analysis}, 45, 2, 249 - 267.

Stefanski, L. and Carroll, R.J. (1990). Deconvoluting kernel density 
estimators. \emph{Statistics}, 21, 2, 169-184.

Delaigle, A. and Hall, P. (2008). Using SIMEX for smoothing-parameter choice 
in errors-in-variables problems. \emph{Journal of the American Statistical 
Association}, 103, 481, 280-287
}

\examples{
# CV bandwidth -----------------------------------------------------------------
n <- 200
sigX <- 1
sigU <- 0.2
W <- GenerateTestData(n, sigX, sigU, dist_type = "mix", error_type = "norm")

bw <- bandwidth(W, errortype = "norm", sigU = sigU, algorithm = "CV")


# PI bandwidth with heteroscedastic errors -------------------------------------
n <- 200
sigX <- 1
sigU_vec <- 0.6 * sqrt(1 + (1:n) / n) * sqrt(0.5)
W <- GenerateTestData(n, sigX, sigU_vec, dist_type = "mix", error_type = "norm")
# Estimate the variance of X
varX <- mean(W^2) - (mean(W))^2 - sum(sigU_vec^2) / n

bw <- bandwidth(W, errortype = "norm", sigU = sigU_vec, varX = varX)

# SIMEX bandwidth --------------------------------------------------------------
n <- 200
sigX <- 1
sigU <- 0.2
data <- GenerateTestData(n, sigX, sigU, dist_type = "mix", error_type = "norm", 
						 create_Y = TRUE)
output <- bandwidth(data$W, errortype = "norm", sigU = sigU, Y = data$Y, 
					algorithm = "SIMEX", n_cores = 2)
bw <- output$h

# PI bandwidth with heteroscedastic errors supplied using phiU -----------------
n <- 200
sigX <- 1
sigU_vec <- 0.6 * sqrt(1 + (1:n) / n) * sqrt(0.5)
phiU <- c()
for (sigUk in sigU_vec){
	phiUk <- function(tt) {
		exp(-sigUk^2 * tt^2 / 2)
	}
	phiU <- c(phiU, phiUk)
}

W <- GenerateTestData(n, sigX, sigU_vec, dist_type = "mix", error_type = "norm")

# Estimate the variance of X
varX <- mean(W^2) - (mean(W))^2 - sum(sigU_vec^2) / n

bw <- bandwidth(W, phiU = phiU, varX = varX)
}
\author{
Aurore Delaigle, Timothy Hyndman, Tianying Wang
}

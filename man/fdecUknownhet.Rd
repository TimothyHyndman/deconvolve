% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fdecUknownhet.r
\name{fdecUknownhet}
\alias{fdecUknownhet}
\title{Compute the deconvolution kernel density estimator.}
\usage{
fdecUknownhet(n, xx, W, h, errortype, sigUj, phiUkvec, rescale = 0,
  phiK = phiK2, muK2 = 6, RK = 1024/3003/pi, deltat = 2e-04,
  tt = seq(-1, 1, deltat))
}
\arguments{
\item{n}{Sample size}

\item{xx}{vector of x-values where to compute the deconvolution kernel 
density estimator}

\item{W}{vector of univariate contaminated data}

\item{h}{bandwidth}

\item{errortype}{"Lap" for the case where the error densities are all Laplace
densities and "norm" for the case where the error densities are all normal. 
If you use this way of defining the error then you also need to provide the 
value of sigUj below.}

\item{sigUj}{vector of length n which contains the parameters of each of the 
n Laplace or normal errors.}

\item{phiUkvec}{vector of n functions that give the characteristic functiona 
of the n errors. Produce this vector by c(func1,func2,...,funcn) where each 
funcj is a function of tt}

\item{rescale}{to rescale the estimator so that it integrates to 1 after the 
negative parts have been truncated to zero. Default is 0 (do not rescale). 
If you want to rescale, set to 1 and see more details below.}

\item{phiK}{Fourier transfrom of the kernel. The default is \eqn{(1-t^2)^3} 
on the interval \eqn{[-1,1]}}

\item{muK2}{second moment of the kernel, i.e. \eqn{x^2 K(x) dx}}

\item{RK}{integral of the square of the kernel, i.e. \eqn{ K^2(x) dx}}

\item{deltat}{distance between two points of the t grid.}

\item{tt}{vector of discrete t values on which you approximate the integrals 
in the Fourier domain.}
}
\value{
The outcome is the deconvolution kernel density estimator when the 
errors are heteroscedastic.
}
\description{
Compute the deconvolution kernel density estimator when the errors are 
heteroscedastic, as in Delaigle, A. and Meister, A. (2008). Density 
estimation with heteroscedastic error. Bernoulli, 14, 562-579
}
\details{
PUT DETAILS HERE
}
\section{Warnings}{

\enumerate{
\item Rescaling requires xx to be a fine grid of equispaced x-values that 
covers the whole range of x-values where the estimated density is 
significantly non zero.
\item Changing the kernel: if you change one of the arguments among phiK, 
muK2, RK, deltat and tt, you must change them all as they need to correspond 
to the same kernel.
\item	If phiK is compactly supported, the first and last elements of t 
must be the lower and upper bound of the support of phiK.
\item	If phiK is not compactly supported, the first and last elements of t 
must be larger enough for your discretisation of the intergals to be 
accurate
\item The kernel K here must match the phiK used to compute the bandwidth 
(PI, CV or other)
\item The DKDE can also be computed using the Fast Fourier Transform, which 
	is a bit more complex. See Delaigle, A. and Gijbels, I. (2007). Frequent 
	problems in calculating integrals and optimizing objective functions: a case 
	study in density deconvolution. Statistics and Computing, 17, 349-355
\item However if the grid of t-values is fine enough, the estimator can 
	simply be computed like here without having problems with oscillations.
}
}

\section{References}{

Delaigle, A. and Meister, A. (2008). Density estimation with heteroscedastic error. Bernoulli, 14, 562-579
}

\section{Author}{

Aurore Delaigle
}

\examples{
####This is a example for R package "fDKDEheterosc"

# Author: Aurore Delaigle
# This code illustrates how to use the functions for computing the deconvolution 
# kernel density estimator and its bandwidths in the case where the errors are 
# heteroscedastic

#-----------------------------------------------------
#Start by generating some data contaminated by noise:
#-----------------------------------------------------

#Sample size
n=200

#Generate data from a normal mixture
mu1=-3;
mu2=2;
sig1=1;
sig2=1;

X=rnorm(n,mu1,sig1);
X2=rnorm(n,mu2,sig2);

pmix=0.75;
tmp=matrix(runif(n,0,1),nrow=1,ncol=n,byrow=TRUE);
X[which(tmp<pmix)]=X2[which(tmp<pmix)];

#Grid where to estimate the true mixture density, and calculation of true 
#density
xx=seq(-5,5,0.1);
dx=xx[2]-xx[1];
truedens=(1-pmix)*dnorm(xx,mu1,sig1)+pmix*dnorm(xx,mu2,sig2);



#Standard devation of the jth error, for j=1,...,n
sigU=0.6;
sigmaj=sigU*sqrt(1.0+(1:n)/n)*sqrt(0.5);

#-------------------------------------
#Example when the error is normal
#------------------------------------
errortype="norm";
U=rep(1,n);
for (i in 1:n)
	U[i]=rnorm(1,0,sigmaj[i]);
 
#Contaminated data
W=as.vector(X+U);


#Estimate the variance of X
varX=mean(W^2)-(mean(W))^2-sum(sigmaj^2)/n;

#PI bandwidth of Delaigle and Gijbels
hPI=PI_deconvUknownth4het(n,W,varX,errortype,sigmaj);

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y=fdecUknownhet(n,xx,W,hPI,errortype,sigmaj);

#DKDE estimator with rescaling: here xx must be equispaced and must cover the 
#range where the estimated density is significantly non zero
y2=fdecUknownhet(n,xx,W,hPI,errortype,sigmaj,rescale=1);

#Plot the true density
plot(xx,truedens,'l',col='red',xlab="",ylab="")
lines(xx,y,col='black')
lines(xx,y2,col="green")

#Example of how to provide the vector of phiU_k's instead of the error type and 
#the standard deviations

phiUkvec=c()
for(k in 1:n)
{	
	phiUk<-function(tt,k) {return(exp(-sigmaj[k]^2*tt^2/2));}
	phiUkvec=c(phiUkvec,phiUk)
}

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y3=fdecUknownhet(n,xx,W,hPI,phiUkvec=phiUkvec);
lines(xx,y3,col='magenta',lty=2)



#Compare with the naive KDE estimator that ignores the error (using normal 
#reference bandwidth and standard normal kernel)
h=1.06*sqrt(var(W))*n^(-1/5);
xout=outerop(xx,t(W),"-");

fnaive=apply(dnorm(xout,0,h),1,sum)/n;

lines(xx,fnaive,col='cyan')

legend(x="topright",legend=c( "true f","fdec, hPI", "fdec rescaled, hPI", 
	   "fdec hPI v2", "naive estimator, hNR"),
	   col=c("red","black","green","magenta","cyan"),lty=c(1,1,1,2,1),cex=0.73)
# Author: Aurore Delaigle
# This code illustrates how to use the functions for computing the deconvolution 
# kernel density estimator and its bandwidths

#-----------------------------------------------------
#Start by generating some data contaminated by noise:
#-----------------------------------------------------



#Noise to signal ratio=varU/varX
NSR=0.2

#Sample size
n=200

#Generate data from a normal mixture
mu1=-3;
mu2=2;
sig1=1;
sig2=1;

X=rnorm(n,mu1,sig1);
X2=rnorm(n,mu2,sig2);

pmix=0.75;
tmp=matrix(runif(n,0,1),nrow=1,ncol=n,byrow=TRUE);
X[which(tmp<pmix)]=X2[which(tmp<pmix)];

#Grid where to estimate the true mixture density, and calculation of true 
#density
xx=seq(-5,5,0.1);
dx=xx[2]-xx[1];
truedens=(1-pmix)*dnorm(xx,mu1,sig1)+pmix*dnorm(xx,mu2,sig2);



#-------------------------------------
#Example when the error is normal
#-------------------------------------

errortype="norm";
sigU=sqrt(NSR*var(X));
U=rnorm(n,0,sigU);
W=as.vector(X+U);

#Plot the true density
plot(xx,truedens,'l',col='red',xlab="",ylab="")

#PI bandwidth of Delaigle and Gijbels
hPI=PI_deconvUknownth4(n,W,errortype,sigU);

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y=fdecUknown(n,xx,W,hPI,errortype,sigU);

#DKDE estimator with rescaling: here xx must be equispaced and must cover the 
#range where the estimated density is significantly non zero
y2=fdecUknown(n,xx,W,hPI,errortype,sigU,rescale=1);

lines(xx,y2,col="green",xlab="",ylab="")
lines(xx,y,col='black')



#CV bandwidth of Stefanski and Carroll
hCV=CVdeconv(n,W,errortype,sigU)

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y3=fdecUknown(n,xx,W,hCV,errortype,sigU);

lines(xx,y3,col='magenta')



#Compare with the naive KDE estimator that ignores the error (using normal 
#reference bandwidth and standard normal kernel)
h=1.06*sqrt(var(W))*n^(-1/5);
xout=outerop(xx,t(W),"-");

fnaive=apply(dnorm(xout,0,h),1,sum)/n;

lines(xx,fnaive,col='cyan')


legend(x="topright",legend=c( "true f","fdec, hPI", "fdec rescaled, hPI", 
	   "fdec rescaled, hCV", "naive estimator, hNR"),
	   col=c("red","black","green","magenta","cyan"),lty=c(1,1,1,1),cex=0.73)



#-------------------------------------
#Example when the error is Laplace
#-------------------------------------
#windows()
errortype="Lap"
sigLap=sqrt(NSR*var(X)/2)
sigU=sqrt(2)*sigLap;
U=rlap(sigLap,1,n);

#Contaminated data
W=as.vector(X+U);


#Plot the true density
plot(xx,truedens,'l',col='red',xlab="",ylab="")

#PI bandwidth of Delaigle and Gijbels
hPI=PI_deconvUknownth4(n,W,errortype,sigU);


#DKDE estimator without rescaling (density does not integrate exactly to 1)
y=fdecUknown(n,xx,W,hPI,errortype,sigU);

#DKDE estimator with rescaling: here xx must be equispaced and must cover the 
#range where the estimated density is significantly non zero
y2=fdecUknown(n,xx,W,hPI,errortype,sigU,rescale=1);

lines(xx,y2,col="green",xlab="",ylab="")
lines(xx,y,col='black')



#CV bandwidth of Stefanski and Carroll
hCV=CVdeconv(n,W,errortype,sigU)

#DKDE estimator without rescaling (density does not integrate exactly to 1)
y3=fdecUknown(n,xx,W,hCV,errortype,sigU);

lines(xx,y3,col='magenta')



#Compare with the naive KDE estimator that ignores the error (using normal 
#reference bandwidth and standard normal kernel)
h=1.06*sqrt(var(W))*n^(-1/5);
xout=outerop(xx,t(W),"-");

fnaive=apply(dnorm(xout,0,h),1,sum)/n;

lines(xx,fnaive,col='cyan')


legend(x="topright",legend=c( "true f","fdec, hPI", "fdec rescaled, hPI", 
	   "fdec rescaled, hCV", "naive estimator, hNR"),
	   col=c("red","black","green","magenta","cyan"),lty=c(1,1,1,1),cex=0.73)
}
\keyword{deconvolution}
\keyword{density}
\keyword{estimator}
\keyword{heteroscedastic}
\keyword{kernel}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/het_deconvolve_U_known.r
\name{het_deconvolve_U_known}
\alias{het_deconvolve_U_known}
\title{Deconvolution Kernel Density Estimator when the errors are known and 
heteroscedastic}
\usage{
het_deconvolve_U_known(W, phiU, h, x = seq(min(W), max(W), length.out = 100),
  kernel_type = c("default", "normal", "sinc"), rescale = FALSE)
}
\arguments{
\item{W}{A vector of the univariate contaminated data.}

\item{phiU}{A vector of functions giving the characteristic functions of 
\eqn{U}. Must have the same length as \code{W}.}

\item{h}{The bandwidth to use.}

\item{x}{A vector of x values on which to compute the density.}

\item{kernel_type}{The deconvolution kernel to use. The default kernel has
characteristic function \eqn{(1-t^2)^3}.}

\item{rescale}{If \code{TRUE}, estimator is rescaled so that it 
integrates to 1. Rescaling requires \code{x} to be a fine grid of equispaced 
\eqn{x} values that covers the whole range of \eqn{x}-values where the 
estimated density is significantly non zero.}
}
\value{
An object of class "\code{deconvolve}" containing the elements
\item{W}{The original contaminated data}
\item{x}{The values on which the deconvolution KDE is evaluated.}
\item{pdf}{A vector containing the deconvolution KDE evaluated at each point 
in \code{x}}

The function \code{plot} produces a plot of the deconvolution KDE.
}
\description{
Computes the deconvolution kernel density estimator (KDE) of \eqn{X} from 
data \eqn{W = X + U} when the distributions of \eqn{U} are known and 
heteroscedastic.
}
\details{
The method used is as described in Delaigle and Meister 2008.
}
\section{Warnings}{

\itemize{
\item You should ensure that the kernel used here matches the one you used 
	to calculate your bandwidth.
\item The DKDE can also be computed using the Fast Fourier Transform, which 
	is a bit more complex. See Delaigle and Gijbels 2007. However if the grid of 
	t-values is fine enough, the estimator can simply be computed like here 
	without having problems with oscillations.
}
}

\section{References}{

Delaigle, A. and Meister, A. (2008). Density estimation with heteroscedastic 
error. \emph{Bernoulli}, 14, 2, 562-579.

Delaigle, A. and Gijbels, I. (2007). Frequent problems in calculating 
integrals and optimizing objective functions: a case study in density 
deconvolution. \emph{Statistics and Computing}, 17, 349-355.
}

\examples{
# Generate some data to work with
n <- 100
sd_U <- 0.6 * sqrt(1 + (1:n) / n) * sqrt(0.5)
X <- stats::rchisq(n, df = 3)
for (sd in sd_U) {
	U[i] <- stats::rnorm(1, 0, sd)
}
W <- X + U

# Create phiUs
phiU <- create_phiU(sd_U, "norm")

# Calculate a bandwidth
h <- bandwidth(W, sd_U = sd_U, phiU = phiU)

# Deconvolve
yy <- deconvolve(W, phiU, h)
}
\author{
Aurore Delaigle, Timothy Hyndman, Tianying Wang
}
